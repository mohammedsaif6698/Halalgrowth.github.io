## üìÅ `/app/backend/server.py`

```python
from fastapi import FastAPI, APIRouter, HTTPException, Depends, File, UploadFile, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from dotenv import load_dotenv
from starlette.middleware.cors import CORSMiddleware
from motor.motor_asyncio import AsyncIOMotorClient
from passlib.context import CryptContext
from jose import JWTError, jwt
from datetime import datetime, timedelta, timezone
from pydantic import BaseModel, Field, EmailStr, ConfigDict
from typing import List, Optional
import os
import logging
import uuid
import aiofiles
from pathlib import Path

ROOT_DIR = Path(__file__).parent
load_dotenv(ROOT_DIR / '.env')

# MongoDB connection
mongo_url = os.environ['MONGO_URL']
client = AsyncIOMotorClient(mongo_url)
db = client[os.environ['DB_NAME']]

# Password hashing
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# JWT settings
SECRET_KEY = os.environ.get('SECRET_KEY', 'your-secret-key-change-in-production')
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 60 * 24 * 7  # 7 days

# Admin credentials
ADMIN_EMAIL = "saifuddin66986698@gmail.com"
ADMIN_PASSWORD = "mohdsaif07"

# Create the main app
app = FastAPI()
api_router = APIRouter(prefix="/api")
security = HTTPBearer()

# Ensure uploads directory exists
UPLOAD_DIR = ROOT_DIR / "uploads"
UPLOAD_DIR.mkdir(exist_ok=True)

# ==================== Models ====================

class UserCreate(BaseModel):
    name: str
    email: EmailStr
    password: str

class UserLogin(BaseModel):
    email: EmailStr
    password: str

class UserResponse(BaseModel):
    id: str
    name: str
    email: str
    balance: float
    referral_code: str
    is_admin: bool

class BankDetails(BaseModel):
    account_number: str
    ifsc_code: str
    account_holder_name: str

class UPIDetails(BaseModel):
    vpa: str  # Virtual Payment Address

class PackageCreate(BaseModel):
    name: str
    price: float

class PackageResponse(BaseModel):
    id: str
    name: str
    price: float
    created_at: str

class PurchaseResponse(BaseModel):
    id: str
    user_id: str
    package_id: str
    package_name: str
    amount: float
    status: str  # pending, verified
    upi_screenshot: Optional[str] = None
    created_at: str
    verified_at: Optional[str] = None

class WithdrawRequest(BaseModel):
    amount: float
    method: str  # bank or upi

class TransactionResponse(BaseModel):
    id: str
    user_id: str
    type: str  # purchase, withdrawal, commission_received, commission_paid
    amount: float
    details: str
    timestamp: str

class ReferralStats(BaseModel):
    referral_code: str
    referral_link: str
    total_referrals: int
    total_earnings: float
    referrals: List[dict]

# ==================== Helper Functions ====================

def hash_password(password: str) -> str:
    return pwd_context.hash(password)

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)

def create_access_token(data: dict) -> str:
    to_encode = data.copy()
    expire = datetime.now(timezone.utc) + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)

def generate_referral_code() -> str:
    return str(uuid.uuid4())[:8].upper()

async def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)):
    token = credentials.credentials
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        user_id: str = payload.get("sub")
        if user_id is None:
            raise HTTPException(status_code=401, detail="Invalid authentication credentials")
    except JWTError:
        raise HTTPException(status_code=401, detail="Invalid authentication credentials")
    
    user = await db.users.find_one({"id": user_id})
    if user is None:
        raise HTTPException(status_code=401, detail="User not found")
    return user

async def get_admin_user(current_user: dict = Depends(get_current_user)):
    if not current_user.get("is_admin", False):
        raise HTTPException(status_code=403, detail="Admin access required")
    return current_user

# ==================== Auth Routes ====================

@api_router.post("/auth/register", response_model=UserResponse)
async def register(user_data: UserCreate):
    # Check if user exists
    existing_user = await db.users.find_one({"email": user_data.email})
    if existing_user:
        raise HTTPException(status_code=400, detail="Email already registered")
    
    # Determine if this is admin
    is_admin = user_data.email == ADMIN_EMAIL
    
    # Create user
    user = {
        "id": str(uuid.uuid4()),
        "name": user_data.name,
        "email": user_data.email,
        "password": hash_password(user_data.password if not is_admin else ADMIN_PASSWORD),
        "balance": 0.0,
        "referral_code": generate_referral_code(),
        "referred_by": None,
        "bank_details": None,
        "upi_details": None,
        "is_admin": is_admin,
        "created_at": datetime.now(timezone.utc).isoformat()
    }
    
    await db.users.insert_one(user)
    
    return UserResponse(
        id=user["id"],
        name=user["name"],
        email=user["email"],
        balance=user["balance"],
        referral_code=user["referral_code"],
        is_admin=user["is_admin"]
    )

@api_router.post("/auth/login")
async def login(credentials: UserLogin):
    user = await db.users.find_one({"email": credentials.email})
    if not user:
        raise HTTPException(status_code=401, detail="Invalid email or password")
    
    if not verify_password(credentials.password, user["password"]):
        raise HTTPException(status_code=401, detail="Invalid email or password")
    
    access_token = create_access_token({"sub": user["id"]})
    
    return {
        "access_token": access_token,
        "token_type": "bearer",
        "user": UserResponse(
            id=user["id"],
            name=user["name"],
            email=user["email"],
            balance=user["balance"],
            referral_code=user["referral_code"],
            is_admin=user.get("is_admin", False)
        )
    }

@api_router.get("/auth/me", response_model=UserResponse)
async def get_me(current_user: dict = Depends(get_current_user)):
    return UserResponse(
        id=current_user["id"],
        name=current_user["name"],
        email=current_user["email"],
        balance=current_user["balance"],
        referral_code=current_user["referral_code"],
        is_admin=current_user.get("is_admin", False)
    )

# ==================== Package Routes ====================

@api_router.get("/packages", response_model=List[PackageResponse])
async def get_packages():
    packages = await db.packages.find({}, {"_id": 0}).to_list(1000)
    return packages

@api_router.post("/packages", response_model=PackageResponse)
async def create_package(package: PackageCreate, admin_user: dict = Depends(get_admin_user)):
    new_package = {
        "id": str(uuid.uuid4()),
        "name": package.name,
        "price": package.price,
        "created_at": datetime.now(timezone.utc).isoformat()
    }
    await db.packages.insert_one(new_package)
    return PackageResponse(**new_package)

@api_router.put("/packages/{package_id}", response_model=PackageResponse)
async def update_package(package_id: str, package: PackageCreate, admin_user: dict = Depends(get_admin_user)):
    result = await db.packages.find_one_and_update(
        {"id": package_id},
        {"$set": {"name": package.name, "price": package.price}},
        return_document=True
    )
    if not result:
        raise HTTPException(status_code=404, detail="Package not found")
    return PackageResponse(**result)

@api_router.delete("/packages/{package_id}")
async def delete_package(package_id: str, admin_user: dict = Depends(get_admin_user)):
    result = await db.packages.delete_one({"id": package_id})
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Package not found")
    return {"message": "Package deleted successfully"}

# ==================== Purchase Routes ====================

@api_router.post("/purchase/{package_id}")
async def purchase_package(
    package_id: str,
    referral_code: Optional[str] = None,
    upi_screenshot: UploadFile = File(...),
    current_user: dict = Depends(get_current_user)
):
    # Get package
    package = await db.packages.find_one({"id": package_id})
    if not package:
        raise HTTPException(status_code=404, detail="Package not found")
    
    # Save UPI screenshot
    file_extension = upi_screenshot.filename.split('.')[-1]
    filename = f"{uuid.uuid4()}.{file_extension}"
    file_path = UPLOAD_DIR / filename
    
    async with aiofiles.open(file_path, 'wb') as out_file:
        content = await upi_screenshot.read()
        await out_file.write(content)
    
    # Verify referral code if provided
    referrer = None
    if referral_code:
        referrer = await db.users.find_one({"referral_code": referral_code})
        if not referrer:
            referral_code = None  # Invalid code, ignore it
    
    # Create purchase record
    purchase = {
        "id": str(uuid.uuid4()),
        "user_id": current_user["id"],
        "package_id": package["id"],
        "package_name": package["name"],
        "amount": package["price"],
        "status": "pending",
        "upi_screenshot": filename,
        "referral_code_used": referral_code,
        "created_at": datetime.now(timezone.utc).isoformat(),
        "verified_at": None,
        "verification_scheduled": (datetime.now(timezone.utc) + timedelta(hours=2)).isoformat()
    }
    
    await db.purchases.insert_one(purchase)
    
    return {
        "message": "Purchase initiated. Payment will be verified within 2 hours.",
        "purchase_id": purchase["id"],
        "verification_time": purchase["verification_scheduled"]
    }

@api_router.get("/purchases", response_model=List[PurchaseResponse])
async def get_user_purchases(current_user: dict = Depends(get_current_user)):
    purchases = await db.purchases.find({"user_id": current_user["id"]}, {"_id": 0}).to_list(1000)
    return purchases

@api_router.get("/purchases/all", response_model=List[PurchaseResponse])
async def get_all_purchases(admin_user: dict = Depends(get_admin_user)):
    purchases = await db.purchases.find({}, {"_id": 0}).to_list(1000)
    return purchases

@api_router.post("/purchases/{purchase_id}/verify")
async def verify_purchase(purchase_id: str, admin_user: dict = Depends(get_admin_user)):
    purchase = await db.purchases.find_one({"id": purchase_id})
    if not purchase:
        raise HTTPException(status_code=404, detail="Purchase not found")
    
    if purchase["status"] == "verified":
        raise HTTPException(status_code=400, detail="Purchase already verified")
    
    # Update purchase status
    await db.purchases.update_one(
        {"id": purchase_id},
        {"$set": {"status": "verified", "verified_at": datetime.now(timezone.utc).isoformat()}}
    )
    
    # Credit balance to user (100% of package price)
    await db.users.update_one(
        {"id": purchase["user_id"]},
        {"$inc": {"balance": purchase["amount"]}}
    )
    
    # Create transaction for buyer
    buyer_transaction = {
        "id": str(uuid.uuid4()),
        "user_id": purchase["user_id"],
        "type": "purchase",
        "amount": purchase["amount"],
        "details": f"Package purchase verified: {purchase['package_name']}",
        "timestamp": datetime.now(timezone.utc).isoformat()
    }
    await db.transactions.insert_one(buyer_transaction)
    
    # Handle referral commissions
    if purchase.get("referral_code_used"):
        referrer = await db.users.find_one({"referral_code": purchase["referral_code_used"]})
        admin = await db.users.find_one({"email": ADMIN_EMAIL})
        
        if referrer and admin:
            referrer_commission = purchase["amount"] * 0.25  # 25%
            admin_commission = purchase["amount"] * 0.75  # 75%
            
            # Credit referrer
            await db.users.update_one(
                {"id": referrer["id"]},
                {"$inc": {"balance": referrer_commission}}
            )
            
            # Credit admin
            await db.users.update_one(
                {"id": admin["id"]},
                {"$inc": {"balance": admin_commission}}
            )
            
            # Create transactions
            referrer_transaction = {
                "id": str(uuid.uuid4()),
                "user_id": referrer["id"],
                "type": "commission_received",
                "amount": referrer_commission,
                "details": f"Referral commission from {purchase['package_name']} purchase",
                "timestamp": datetime.now(timezone.utc).isoformat()
            }
            await db.transactions.insert_one(referrer_transaction)
            
            admin_transaction = {
                "id": str(uuid.uuid4()),
                "user_id": admin["id"],
                "type": "commission_received",
                "amount": admin_commission,
                "details": f"Admin commission from referred {purchase['package_name']} purchase",
                "timestamp": datetime.now(timezone.utc).isoformat()
            }
            await db.transactions.insert_one(admin_transaction)
    
    return {"message": "Purchase verified and balance credited successfully"}

# ==================== User Profile Routes ====================

@api_router.post("/user/bank")
async def add_bank_details(bank: BankDetails, current_user: dict = Depends(get_current_user)):
    await db.users.update_one(
        {"id": current_user["id"]},
        {"$set": {"bank_details": bank.model_dump()}}
    )
    return {"message": "Bank details saved successfully"}

@api_router.post("/user/upi")
async def add_upi_details(upi: UPIDetails, current_user: dict = Depends(get_current_user)):
    await db.users.update_one(
        {"id": current_user["id"]},
        {"$set": {"upi_details": upi.model_dump()}}
    )
    return {"message": "UPI details saved successfully"}

@api_router.get("/user/referrals", response_model=ReferralStats)
async def get_referral_stats(current_user: dict = Depends(get_current_user)):
    # Find all users referred by current user
    referrals = await db.users.find({"referred_by": current_user["referral_code"]}, {"_id": 0}).to_list(1000)
    
    # Calculate total earnings from referrals
    referral_transactions = await db.transactions.find({
        "user_id": current_user["id"],
        "type": "commission_received"
    }, {"_id": 0}).to_list(1000)
    
    total_earnings = sum(t["amount"] for t in referral_transactions)
    
    referral_list = [{"name": r["name"], "email": r["email"], "joined_at": r["created_at"]} for r in referrals]
    
    base_url = os.environ.get('FRONTEND_URL', 'http://localhost:3000')
    
    return ReferralStats(
        referral_code=current_user["referral_code"],
        referral_link=f"{base_url}/register?ref={current_user['referral_code']}",
        total_referrals=len(referrals),
        total_earnings=total_earnings,
        referrals=referral_list
    )

@api_router.get("/user/transactions", response_model=List[TransactionResponse])
async def get_transactions(current_user: dict = Depends(get_current_user)):
    transactions = await db.transactions.find({"user_id": current_user["id"]}, {"_id": 0}).sort("timestamp", -1).to_list(1000)
    return transactions

# ==================== Withdrawal Routes (MOCKED) ====================

@api_router.post("/withdraw")
async def withdraw_funds(withdraw: WithdrawRequest, current_user: dict = Depends(get_current_user)):
    # Check balance
    if withdraw.amount > current_user["balance"]:
        raise HTTPException(status_code=400, detail="Insufficient balance")
    
    # Check withdrawal method details
    if withdraw.method == "bank":
        if not current_user.get("bank_details"):
            raise HTTPException(status_code=400, detail="Bank details not added. Please add bank details first.")
    elif withdraw.method == "upi":
        if not current_user.get("upi_details"):
            raise HTTPException(status_code=400, detail="UPI details not added. Please add UPI details first.")
    else:
        raise HTTPException(status_code=400, detail="Invalid withdrawal method. Use 'bank' or 'upi'.")
    
    # MOCKED: Simulate Cashfree API call
    withdrawal_id = str(uuid.uuid4())
    
    # Deduct balance
    await db.users.update_one(
        {"id": current_user["id"]},
        {"$inc": {"balance": -withdraw.amount}}
    )
    
    # Create transaction
    transaction = {
        "id": str(uuid.uuid4()),
        "user_id": current_user["id"],
        "type": "withdrawal",
        "amount": withdraw.amount,
        "details": f"Withdrawal via {withdraw.method.upper()} - MOCKED (No real Cashfree integration)",
        "timestamp": datetime.now(timezone.utc).isoformat()
    }
    await db.transactions.insert_one(transaction)
    
    # Create withdrawal record
    withdrawal_record = {
        "id": withdrawal_id,
        "user_id": current_user["id"],
        "amount": withdraw.amount,
        "method": withdraw.method,
        "status": "success_mocked",
        "details": current_user.get("bank_details") if withdraw.method == "bank" else current_user.get("upi_details"),
        "timestamp": datetime.now(timezone.utc).isoformat()
    }
    await db.withdrawals.insert_one(withdrawal_record)
    
    return {
        "message": "Withdrawal processed successfully (MOCKED - No real money transferred)",
        "withdrawal_id": withdrawal_id,
        "amount": withdraw.amount,
        "method": withdraw.method,
        "note": "This is a MOCKED withdrawal. Cashfree integration not active."
    }

@api_router.get("/withdrawals")
async def get_withdrawals(current_user: dict = Depends(get_current_user)):
    withdrawals = await db.withdrawals.find({"user_id": current_user["id"]}, {"_id": 0}).sort("timestamp", -1).to_list(1000)
    return withdrawals

# ==================== Include Router ====================

app.include_router(api_router)

app.add_middleware(
    CORSMiddleware,
    allow_credentials=True,
    allow_origins=os.environ.get('CORS_ORIGINS', '*').split(','),
    allow_methods=["*"],
    allow_headers=["*"],
)

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

@app.on_event("shutdown")
async def shutdown_db_client():
    client.close()
```

---

## üìÅ `/app/backend/requirements.txt`

```txt
fastapi==0.110.1
uvicorn==0.25.0
python-dotenv>=1.0.1
pymongo==4.5.0
pydantic>=2.6.4
email-validator>=2.2.0
pyjwt>=2.10.1
bcrypt==4.1.3
passlib>=1.7.4
motor==3.3.1
python-jose>=3.3.0
python-multipart>=0.0.9
aiofiles>=23.2.1
```

---

## üìÅ `/app/backend/.env`

```env
MONGO_URL="mongodb://localhost:27017"
DB_NAME="halal_growth"
CORS_ORIGINS="*"